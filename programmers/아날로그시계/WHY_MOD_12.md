# % 12를 사용하는 이유 설명

## ❓ 왜 `h % 12`가 아니라 `if (h >= 12)` 처리를 해야 하나?

### 🔴 잘못된 접근 (기존 코드)

```java
h = h % 12;  // 14시 → 2시로 변환
totalSeconds = h * 3600 + m * 60 + s;
```

**문제점:**
- `countAlarms(14, 0, 0)`을 호출하면
- `h = 14 % 12 = 2`
- `totalSeconds = 2 * 3600 = 7200` (2시간)
- **0시부터 14시까지가 아니라 0시부터 2시까지만 계산됨!**

### ✅ 올바른 접근 (수정된 코드)

```java
if (h >= 12) {
    total += 1426;  // 0시~12시 동안의 알람 1426번
    h -= 12;        // 14시 → 2시
}
totalSeconds = h * 3600 + m * 60 + s;  // 나머지 2시간
```

**이제 제대로 계산:**
- `countAlarms(14, 0, 0)`을 호출하면
- `h >= 12`이므로 먼저 `total = 1426` (0~12시)
- `h = 14 - 12 = 2`
- `totalSeconds = 7200` (12시~14시의 2시간)
- **0시부터 14시까지 올바르게 계산!**

## 📊 구체적인 예시

### 예제: 11시 ~ 14시 동안 알람 횟수 계산

```java
solution(11, 0, 0, 14, 0, 0)
```

**계산 과정:**

1. **`countAlarms(14, 0, 0)`** (종료 시각)
   - `h >= 12`이므로 `total = 1426`
   - `h = 14 - 12 = 2`
   - 2시간 동안: `(719 × 7200 / 43200) + (59 × 7200 / 3600)` = 119 + 118 = 237
   - 최종: **1426 + 237 = 1663**

2. **`countAlarms(11, 0, 0)`** (시작 시각)
   - `h < 12`이므로 `total = 0`
   - 11시간 동안: `(719 × 39600 / 43200) + (59 × 39600 / 3600)` = 659 + 649 = 1308
   - 최종: **1308**

3. **구간 알람 횟수**
   - `1663 - 1308 = 355`번

### 왜 % 12를 사용하는가?

**아날로그 시계는 12시간 주기입니다:**
- 0시와 12시의 시침 위치는 **똑같음**
- 1시와 13시의 시침 위치는 **똑같음**
- 따라서 시침의 **각도 계산**에는 `h % 12` 사용

```java
// isAlarmTime 함수에서
double hourAngle = ((h % 12) * 3600 + m * 60 + s) / 120.0;
```

하지만 **누적 알람 횟수**를 계산할 때는:
- 0~12시: 1426번
- 12~24시: 또 1426번
- 따라서 12시간마다 1426번씩 추가해야 함!

## 🎯 핵심 정리

| 용도 | 방법 | 이유 |
|------|------|------|
| **각도 계산** | `h % 12` | 시침은 12시간 주기로 반복 |
| **누적 횟수** | `if (h >= 12) total += 1426` | 12시간 동안의 알람을 누적 |

## 💡 왜 1426번인가?

**0시 0분 0초 ~ 12시 0분 0초 (12시간 = 43200초)**
- 초침-시침: 719번
- 초침-분침: 708번
- 합계: 1427번
- 0시 정각 중복: -1번
- **최종: 1426번**

하지만 12시 0분 0초는 포함하지 않으므로 실제로는:
- 초침-시침: `(719 × 43200) / 43200 = 719`
- 초침-분침: `(59 × 43200) / 3600 = 708`
- 합계: 1427
- 0시 정각: -1
- **1426번!** ✅
